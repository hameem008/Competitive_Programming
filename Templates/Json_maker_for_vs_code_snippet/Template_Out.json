"pair<ll, ll> func(ll n)\r\n{\r\n    ll k;\r\n    k = log2(n);\r\n    pair<ll, ll> ret = {k, powl(2, k)};\r\n    return ret;\r\n}\r\nvector<vector<ll>> bin_lift;\r\nvector<ll> next_child;\r\nvoid bin_lift_func(ll vertex, vector<vector<ll>> &graph, vector<bool> &isVisited, vector<ll> parv, ll level)\r\n{\r\n    isVisited[vertex] = true;\r\n    if (level > 0)\r\n    {\r\n        for (auto x : parv)\r\n            bin_lift[vertex].push_back(next_child[x]);\r\n        pair<ll, ll> pr = func(level);\r\n        if (pr.second == level)\r\n            bin_lift[vertex].push_back(1);\r\n    }\r\n    for (auto x : graph[vertex])\r\n    {\r\n        if (!isVisited[x])\r\n        {\r\n            next_child[vertex] = x;\r\n            bin_lift_func(x, graph, isVisited, bin_lift[vertex], level + 1);\r\n        }\r\n    }\r\n}\r\nll get_kth_parrent(ll node, ll kth_parrent)\r\n{\r\n    while (1)\r\n    {\r\n        pair<ll, ll> pr = func(kth_parrent);\r\n        ll pow_2 = pr.first;\r\n        ll powl_ = pr.second;\r\n        if (powl_ == kth_parrent && pow_2 < bin_lift[node].size())\r\n            return bin_lift[node][pow_2];\r\n        else if (pow_2 < bin_lift[node].size())\r\n        {\r\n            node = bin_lift[node][pow_2];\r\n            kth_parrent -= powl_;\r\n        }\r\n        else\r\n            return -1;\r\n    }\r\n}\r\nvector<ll> start_time, end_time, level_of;\r\nll time_ = 0;\r\nvoid calc_time(ll vertex, vector<vector<ll>> &graph, vector<bool> &isVisited, ll level)\r\n{\r\n    isVisited[vertex] = true;\r\n    level_of[vertex] = level;\r\n    time_++;\r\n    start_time[vertex] = time_;\r\n    for (auto x : graph[vertex])\r\n    {\r\n        if (!isVisited[x])\r\n        {\r\n            calc_time(x, graph, isVisited, level + 1);\r\n        }\r\n    }\r\n    time_++;\r\n    end_time[vertex] = time_;\r\n}\r\nll least_common_ancestor(ll u, ll v)\r\n{\r\n    if (start_time[u] <= start_time[v] && end_time[u] >= end_time[v])\r\n        return u;\r\n    else if (start_time[v] <= start_time[u] && end_time[v] >= end_time[u])\r\n        return v;\r\n    ll lca;\r\n    lca = u;\r\n    while (1)\r\n    {\r\n        ll dum;\r\n        for (int i = 0; i < bin_lift[lca].size(); i++)\r\n        {\r\n            ll k = bin_lift[lca][i];\r\n            if (start_time[k] < start_time[v] && end_time[k] > end_time[v])\r\n            {\r\n                if (i == 0)\r\n                {\r\n                    return k;\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            else\r\n                dum = k;\r\n        }\r\n        lca = dum;\r\n    }\r\n    return lca;\r\n}\r\nvoid init(ll n)\r\n{\r\n    vector<ll> v;\r\n    bin_lift.assign(n + 1, v);\r\n    next_child.assign(n + 1, 0);\r\n    start_time.assign(n + 1, 0);\r\n    end_time.assign(n + 1, 0);\r\n    level_of.assign(n + 1, 0);\r\n}\r\nvoid pre_processing(ll number_of_nodes, vector<vector<ll>> &graph, ll root)\r\n{\r\n    init(number_of_nodes);\r\n    vector<bool> isVIsited(number_of_nodes + 1, false);\r\n    vector<ll> v;\r\n    bin_lift_func(root, graph, isVIsited, v, 0);\r\n    isVIsited.assign(number_of_nodes + 1, false);\r\n    calc_time(root, graph, isVIsited, 0);\r\n}"